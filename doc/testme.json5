/*
    testme.json5 - Sample TestMe configuration file
 */
{
    /*
        Enable or disable tests in this directory
        - true: Enable tests (default)
        - false: Disable tests completely
        - 'manual': Only run when explicitly named on command line
     */
    enable: true,

    /*
        Minimum depth required to run tests in this directory (default: 0)
        Use tm --depth N to run tests with depth <= N
     */
    depth: 0,

    /*
        Build profile (dev, prod, debug, release, etc.)
        Priority: --profile CLI arg > env.PROFILE > 'dev' (default)
        Used in ${PROFILE} variable expansion
     */
    profile: 'dev',

    /*
        Inherit configuration from parent directory's testme.json5
        - inherit: true → inherit all keys from parent (compiler, debug, execution, output, patterns, services, environment, profile)
        - inherit: ['environment', 'compiler'] → inherit only specified keys
        - inherit: false or omitted → no inheritance (default)

        Inheritance is recursive - parent configs can also inherit from their parents.
        Child settings always override parent settings (deep merge for objects like environment and compiler).

        Path Resolution:
        - Relative paths in parent configs (../../build, ../src) are resolved to absolute paths before inheritance
        - This allows child configs at any depth to inherit paths without adjustment
        - Example: Parent has '-I../../build/inc', child inherits '-I/absolute/path/build/inc'
        - Works for compiler flags (-I, -L, /I, /LIBPATH:) and environment variables
        - Paths with ${...} variables are not resolved (expanded later during execution)

        Example use cases:
        - Project root has common compiler flags and env vars with ../../build paths
        - Subdirectories at any depth can inherit without changing paths
        - Test directory inherits and adds module-specific settings
     */
    // inherit: true,
    // inherit: ['environment', 'compiler', 'debug'],

    /*
         Compiler configuration for different languages
     */
    compiler: {
        c: {
            /*
                Compiler selection has three modes:
                1. Auto-detect (default): compiler: 'default'
                2. Explicit compiler for all platforms: compiler: 'gcc'
                3. Per-platform compiler map:
                compiler: {
                    windows: 'msvc',
                    macosx: 'clang',
                    linux: 'gcc'
                }
            */
            compiler: 'default',

            /*
                GCC-specific flags (Unix/Linux/MinGW)
                Default flags are automatically added: -std=c99 -Wall -Wextra -Wno-unused-parameter -Wno-strict-prototypes -O0 -g -I. -I~/.local/include -L~/.local/lib -I/opt/homebrew/include -L/opt/homebrew/lib

                Platform-specific overrides are supported:
                gcc: {
                    flags: ['-I..'],              // Common flags for all platforms
                    libraries: ['m', 'pthread'],  // Common libraries for all platforms
                    macosx: {
                        flags: ['-framework', 'IOKit'],  // Additional flags for macOS
                        libraries: ['objc'],             // Additional libraries for macOS
                    },
                    linux: {
                        flags: ['-D_GNU_SOURCE'],   // Additional flags for Linux
                        libraries: ['rt'],          // Additional libraries for Linux
                    },
                }
             */
            gcc: {
                flags: [
                    '-I..',
                    '-I${../build/${PLATFORM}-${PROFILE}/inc',
                    '-L${../build/${PLATFORM}-${PROFILE}/bin',
                    // Runtime library search path - automatically converted to platform-specific format:
                    // macOS: @executable_path, Linux: $ORIGIN, Windows: not applicable
                    '-Wl,-rpath,@executable_path/${CONFIGDIR}/../build/${PLATFORM}-${PROFILE}/bin',
                ],
                libraries: ['m', 'pthread'],
            },

            /*
                Clang-specific flags (macOS/Unix)
                Default flags are automatically added: -std=c99 -Wall -Wextra -Wno-unused-parameter -Wno-strict-prototypes -O0 -g -I. -I~/.local/include -L~/.local/lib -I/opt/homebrew/include -L/opt/homebrew/lib

                Platform-specific overrides are also supported (see gcc example above)
            */
            clang: {
                flags: [
                    '-I..',
                    '-I${../build/${PLATFORM}-${PROFILE}/inc',
                    '-L${../build/${PLATFORM}-${PROFILE}/bin',
                    // Runtime library search path - automatically converted to platform-specific format:
                    // macOS: @executable_path, Linux: $ORIGIN, Windows: not applicable
                    '-Wl,-rpath,@executable_path/${CONFIGDIR}/../build/${PLATFORM}-${PROFILE}/bin',
                ],
                libraries: ['m', 'pthread'],
            },

            /*
                MSVC-specific flags (Windows)
                Default flags are automatically added: /std:c11 /W4 /Od /Zi /nologo
            */
            msvc: {
                flags: ['/I.', '/I..', '/I${../build/${PLATFORM}-${PROFILE}/inc'],
                libraries: [],
            },
        },
        es: {
            // Ejscript module to require (supports ~ and ${} expansion)
            require: '${~/.local/lib/testme/testme.mod}',
        },
    },

    /*
        Debugger configuration for different languages (use with --debug flag)
     */
    debug: {
        /*
            C debugger selection has three modes:
            1. Auto-detect (default): c: 'default'
            2. Explicit debugger for all platforms: c: 'gdb'
            3. Per-platform debugger map:
               c: {
                   windows: 'vs',      // or 'vscode'
                   macosx: 'xcode',    // or 'lldb'
                   linux: 'gdb'        // or 'lldb', 'vscode'
               }
            Valid C debuggers: xcode, lldb, gdb, vs, vscode, or path to executable
         */
        c: 'default',

        // JavaScript debugger: vscode, or path to executable
        // js: 'vscode',

        // TypeScript debugger: vscode, or path to executable
        // ts: 'vscode',

        // Python debugger: vscode, pdb, or path to executable
        // py: 'vscode',

        // Go debugger: vscode, delve, or path to executable
        // go: 'delve',

        // Ejscript debugger: vscode, or path to executable
        // es: 'vscode',
    },

    // Test execution settings
    execution: {
        timeout: 30, // Timeout per test in seconds
        parallel: true, // Run tests in parallel
        workers: 4, // Number of parallel workers
        // keepArtifacts: false, // Keep .testme directories after tests (CLI: --keep)
        // stepMode: false, // Pause after each test (CLI: --step)
        // depth: 0, // Minimum depth to run tests (CLI: --depth)
        // debugMode: false, // Run tests under debugger (CLI: --debug)
        // showCommands: false, // Show compiler/debugger commands (CLI: --show)
    },

    // Output formatting options
    output: {
        verbose: false, // Show detailed output (CLI: --verbose)
        format: 'simple', // Output format: simple, detailed, json
        colors: true, // Enable colored output
        // quiet: false, // Suppress all output except errors (CLI: --quiet)
        // errorsOnly: false, // Show only failed tests (CLI: --errors-only)
    },

    // File discovery patterns
    patterns: {
        // Base patterns applied to all platforms
        include: ['**/*.tst.c', '**/*.tst.js', '**/*.tst.ts', '**/*.tst.es'],
        exclude: ['**/node_modules/**', '**/.testme/**', '**/.*/**'],

        // Windows-specific patterns (added to base patterns on Windows)
        windows: {
            include: ['**/*.tst.ps1', '**/*.tst.bat', '**/*.tst.cmd'],
        },

        // macOS-specific patterns (added to base patterns on macOS)
        macosx: {
            include: ['**/*.tst.sh'],
        },

        // Linux-specific patterns (added to base patterns on Linux)
        linux: {
            include: ['**/*.tst.sh'],
        },
    },

    // Service management for test setup/teardown
    services: {
        skip: '', // Script to check if tests should be skipped (0=run, non-zero=skip)
        environment: '', // Script to emit environment variables (key=value lines)
        globalPrep: '', // Script to run once before all test groups (global setup)
        prep: '', // Script to run once before tests in this group begin (waits for completion)
        setup: '', // Script to start background service during test execution
        cleanup: '', // Script to run after tests in this group complete
        globalCleanup: '', // Script to run once after all test groups (global teardown)

        /*
            Health check configuration to verify service readiness
            If configured, TestMe will actively poll the service instead of using a fixed setupDelay.
            This provides faster test execution and more reliable service startup detection.

            Type defaults to 'http' if not specified, allowing simple configuration:
            healthCheck: { url: 'http://localhost:8080/health' }

            Types:
            - http: HTTP/HTTPS health check (most common)
            - tcp: TCP port check (for databases, message queues)
            - script: Custom script-based check (using existing tools)
            - file: File existence check (for ready markers)

            Examples:

            HTTP health check (web server):
            healthCheck: {
                type: 'http',                       // Optional: defaults to http
                url: 'http://localhost:3000/health',
                expectedStatus: 200,                // Optional: defaults to 200
                expectedBody: 'OK',                 // Optional: substring match in response
                interval: 100,                      // Optional: poll interval in ms (default: 100)
                timeout: 30                         // Optional: max wait in seconds (default: 30)
            }

            TCP port check (PostgreSQL):
            healthCheck: {
                type: 'tcp',
                host: 'localhost',
                port: 5432,
                timeout: 60
            }

            Script-based check (Redis):
            healthCheck: {
                type: 'script',
                command: 'redis-cli ping',
                expectedExit: 0,                    // Optional: defaults to 0
                timeout: 10
            }

            File existence check (custom service):
            healthCheck: {
                type: 'file',
                path: '/tmp/daemon.ready',
                timeout: 30
            }
        */
        // healthCheck: {
        //     url: 'http://localhost:8080/health'
        // },

        skipTimeout: 30, // Skip script timeout in seconds
        environmentTimeout: 30, // Environment script timeout in seconds
        globalPrepTimeout: 30, // Global prep timeout in seconds
        prepTimeout: 30, // Prep timeout in seconds
        setupTimeout: 30, // Setup timeout in seconds
        cleanupTimeout: 10, // Cleanup timeout in seconds
        globalCleanupTimeout: 10, // Global cleanup timeout in seconds
        setupDelay: 1, // Delay in seconds after setup starts before running tests (default: 1, ignored if healthCheck configured)
        shutdownTimeout: 5, // Wait time in seconds for graceful shutdown before SIGKILL (default: 5)
    },

    /*
        Environment variables to set for test execution
        Supports platform-specific overrides via windows, macosx, linux keys
        Platform-specific variables are merged with base variables

        NOTE: You can also use services.environment to dynamically set environment variables
        by running a script that emits key=value lines. This is useful for:
        - Detecting build artifacts at runtime
        - Reading configuration from external sources
        - Computing values based on system state
        Example: services.environment: './detect-build.sh' (emits BIN=/path/to/bin)

        Variable expansion:
        - ${VAR} expands to environment variable VAR (e.g., ${PATH}, ${HOME})
        - ${path/pattern} expands using glob patterns
        - ${TESTDIR}, ${CONFIGDIR}, ${OS}, ${ARCH}, ${PLATFORM}, ${CC}, ${PROFILE} are special variables
        - Expansion priority: Special variables → Environment variables → Glob patterns
        - Multiple variables in one value: 'DIR: ${HOME}/bin:${PATH}' (both expand)
        - Sequential expansion: Define BASE first, then use ${BASE} in other variables
        - NOTE: Nested expansion like ${${VAR}} is NOT supported

        Undefined variable behavior:
        - Special variables: kept as ${VAR} if undefined (e.g., no file context)
        - Environment variables: kept as ${VAR} if not in process.env
        - Glob patterns: wrapper removed if no matches (${pattern} → pattern)
        - WARNING: Undefined env vars remain as literal ${VAR} in output

        Path separators:
        - Use Unix-style : separators on all platforms
        - Windows automatically converts : to ; for PATH variable
        - Example: PATH: 'mydir:${PATH}' becomes 'mydir;C:\Windows;...' on Windows
     */
    environment: {
        // Base environment variables (all platforms)
        TEST_MODE: 'integration',
        BIN: '${../build/${PLATFORM}-${PROFILE}/bin}',
        HTTP: 'http://localhost:4100',

        // Windows-specific environment variables (merged with base on Windows)
        windows: {
            // Use Unix-style : separator - automatically converted to ; on Windows
            PATH: '${../build/${PLATFORM}-${PROFILE}/bin}:${PATH}',
            LIB_EXT: '.dll',
        },

        // Linux-specific environment variables (merged with base on Linux)
        linux: {
            LD_LIBRARY_PATH: '${../build/${PLATFORM}-${PROFILE}/bin}:${LD_LIBRARY_PATH}',
            LIB_EXT: '.so',
        },

        // macOS-specific environment variables (merged with base on macOS)
        macosx: {
            DYLD_LIBRARY_PATH: '${../build/${PLATFORM}-${PROFILE}/bin}:${DYLD_LIBRARY_PATH}',
            LIB_EXT: '.dylib',
        },
    },
}
