.TH TM 1 "2024-09-28" "TestMe 1.0" "User Commands"
.SH NAME
tm \- Multi-language test runner for embedded development
.SH SYNOPSIS
.B tm
[\fIOPTIONS\fR] [\fIPATTERNS\fR...]
.SH DESCRIPTION
.B tm
is a multi-language test runner built with Bun that discovers, compiles, and executes tests across shell, C, JavaScript, and TypeScript with configurable patterns and parallel execution. It is designed for embedded development environments and provides a simple, consistent interface for running tests.

TestMe discovers test files with specific extensions (\fB.tst.sh\fR, \fB.tst.c\fR, \fB.tst.js\fR, \fB.tst.ts\fR, \fB.tst.es\fR) and executes them according to their type. C tests are automatically compiled before execution, while script tests are run directly.

By default, TestMe shows test names as they execute and displays a summary of results. Use \fB\-\-quiet\fR for silent operation with only exit codes, or \fB\-\-verbose\fR for detailed output with additional information.

.SH OPTIONS
.TP
.BR \-\-chdir " " \fIDIR\fR
Change to directory before running tests. Useful for running tests from different locations.
.TP
.BR \-\-clean
Clean all .testme artifact directories. Removes compilation outputs and temporary files.
.TP
.BR \-c ", " \-\-config " " \fIFILE\fR
Use specific configuration file instead of searching for testme.json5.
.TP
.BR \-\-continue
Continue running tests even if some fail, and always exit with status 0. Useful for CI/CD environments where you want to collect all test results regardless of failures.
.TP
.BR \-d ", " \-\-debug
Launch debugger for C tests. Uses GDB on Linux and Xcode on macOS.
.TP
.BR \-\-depth " " \fINUMBER\fR
Run tests with depth requirement <= NUMBER (default: 0). Tests with higher depth requirements in their configuration will be skipped. Sets TESTME_DEPTH environment variable for tests.
.TP
.BR \-h ", " \-\-help
Show help message with usage information and examples.
.TP
.BR \-\-init
Create testme.json5 configuration file in the current directory with sensible defaults. Exits with error if file already exists.
.TP
.BR \-k ", " \-\-keep
Keep .testme artifact directories after running tests. Useful for debugging compilation issues.
.TP
.BR \-l ", " \-\-list
List discovered tests without running them. Shows all test files that would be executed.
.TP
.BR \-\-new " " \fINAME\fR
Create new test file from template. Auto-detects test type from extension (e.g., \fB\-\-new math.c\fR creates math.tst.c). Supports C, Shell, JavaScript, and TypeScript templates.
.TP
.BR \-\-no-services
Skip all service commands (skip, prep, setup, cleanup). Use this when you want to run services externally for debugging or manual control.
.TP
.BR \-p ", " \-\-profile " " \fINAME\fR
Set build profile (overrides configuration and PROFILE environment variable). Used in ${PROFILE} variable expansion for platform-specific build paths.
.TP
.BR \-q ", " \-\-quiet
Run silently with no output, only exit codes. Useful for scripting and automation.
.TP
.BR \-s ", " \-\-show
Display the C compile command used. Shows compiler flags, libraries, and paths for debugging.
.TP
.BR \-\-step
Run tests one at a time with prompts. Forces serial mode and prompts before each test execution.
.TP
.BR \-v ", " \-\-verbose
Enable verbose mode with detailed output. Sets TESTME_VERBOSE environment variable for tests.
.TP
.BR \-V ", " \-\-version
Show version information.
.TP
.BR \-w ", " \-\-workers " " \fINUMBER\fR
Number of parallel workers (overrides configuration). Must be a positive integer.

.SH PATTERNS
Test patterns are glob-style expressions used to filter which tests to run:

.TP
.B Full filenames
"math.tst.c", "*.tst.c" - Match specific files or all files of a type
.TP
.B Base names
"math", "test*" - Match base names across all test types (math.tst.c, math.tst.js, etc.)
.TP
.B Directory names
"integration", "unit/api" - Match all tests in the specified directory or subdirectory
.TP
.B Path patterns
"**/math*", "tests/*.tst.c" - Match files in subdirectories or specific paths

If no patterns are provided, all discoverable tests are run.

.SH TEST TYPES
TestMe supports five types of test files:

.TP
.B .tst.sh
Shell script tests. Must be executable or have a shebang line. Exit code 0 indicates success.
.TP
.B .tst.c
C program tests. Automatically compiled with gcc/clang using configuration flags and libraries. Linked against specified libraries and run as executables.
.TP
.B .tst.js
JavaScript tests. Executed directly with the Bun runtime.
.TP
.B .tst.ts
TypeScript tests. Executed directly with Bun's TypeScript support.

.SH TESTING UTILITIES
TestMe provides built-in testing helper functions for C, JavaScript, and TypeScript tests.

.SS C Testing Functions (testme.h)
Include \fBtestme.h\fR in C tests to access these assertion and utility functions:

.TP
.B teq(a, b, msg)
Assert that two values are equal. Prints success message or fails with detailed output.
.TP
.B tneq(a, b, msg)
Assert that two values are not equal.
.TP
.B ttrue(expr, msg)
Assert that expression evaluates to true.
.TP
.B tfalse(expr, msg)
Assert that expression evaluates to false.
.TP
.B tmatch(str, pattern, msg)
Assert that string matches the given pattern.
.TP
.B tcontains(str, substr, msg)
Assert that string contains the given substring.
.TP
.B tfail(msg)
Immediately fail the test with the given message.
.TP
.B tget(key, default)
Get environment variable value with fallback to default.
.TP
.B tgeti(key, default)
Get environment variable as integer with fallback to default.
.TP
.B thas(key)
Check if environment variable exists (returns 1 if exists, 0 otherwise).
.TP
.B tdepth()
Get current test execution depth from TESTME_DEPTH environment variable.
.TP
.B tinfo(...), tdebug(...)
Print informational messages (printf-style formatting).

.SS JavaScript/TypeScript Testing Functions (testme.js)
TestMe provides two testing APIs for JavaScript and TypeScript tests:

.SS Traditional API
Import traditional functions from \fBtestme\fR:

.TP
.B teq(received, expected, msg)
Assert that received value equals expected value.
.TP
.B tneq(received, expected, msg)
Assert that received value does not equal expected value.
.TP
.B ttrue(expr, msg)
Assert that expression is truthy.
.TP
.B tfalse(expr, msg)
Assert that expression is falsy.
.TP
.B tmatch(str, pattern, msg)
Assert that string matches regex pattern.
.TP
.B tcontains(str, substr, msg)
Assert that string contains substring.
.TP
.B tfail(msg)
Immediately fail the test with message.
.TP
.B tget(key, default)
Get environment variable with default fallback.
.TP
.B thas(key)
Check if environment variable exists (returns numeric value).
.TP
.B tverbose()
Check if verbose mode is enabled (returns boolean).
.TP
.B tdepth()
Get current test execution depth.
.TP
.B tinfo(...), tdebug(...)
Print informational messages.
.TP
.B tassert(expr, msg)
Alias for ttrue() function.

.SS Jest/Vitest-Compatible API
TestMe also supports a Jest/Vitest-compatible \fBexpect()\fR API. Import \fBexpect\fR from \fBtestme\fR:

.nf
.RS
import { expect } from 'testme'

expect(1 + 1).toBe(2)
expect({ a: 1 }).toEqual({ a: 1 })
expect('hello').toContain('ell')
expect([1, 2, 3]).toHaveLength(3)

// Negation
expect(5).not.toBe(10)

// Async/Promises
await expect(Promise.resolve(42)).resolves.toBe(42)
.RE
.fi

.B Available Matchers:
.RS
.TP
.B Equality
toBe(), toEqual(), toStrictEqual()
.TP
.B Truthiness
toBeTruthy(), toBeFalsy(), toBeNull(), toBeUndefined(), toBeDefined(), toBeNaN()
.TP
.B Type Checking
toBeInstanceOf(), toBeTypeOf()
.TP
.B Numeric
toBeGreaterThan(), toBeGreaterThanOrEqual(), toBeLessThan(), toBeLessThanOrEqual(), toBeCloseTo()
.TP
.B Strings/Collections
toMatch(), toContain(), toContainEqual(), toHaveLength()
.TP
.B Objects
toHaveProperty(), toMatchObject()
.TP
.B Errors
toThrow(), toThrowError()
.TP
.B Modifiers
.not (negation), .resolves (promise resolution), .rejects (promise rejection)
.RE

Both APIs are fully supported and can be mixed in the same project. All testing functions automatically handle test failure by printing descriptive error messages with file locations and exiting with non-zero status codes.

For complete Jest API documentation, see \fBdoc/JEST_API.md\fR in the TestMe repository.

.SH WORKING DIRECTORY
All tests execute with their working directory (CWD) set to the directory containing the test file. This ensures consistent behavior across all test types and allows tests to access relative files reliably.

.TP
.B C Tests
Compiled in the .testme artifact directory but executed from the test file's directory. Xcode debugging projects also set the working directory to the test directory.
.TP
.B Script Tests
Shell, JavaScript, and TypeScript tests execute directly from the test file's directory.
.TP
.B Relative File Access
Tests can reliably access configuration files, data files, and other resources using relative paths from their location.

.SH CONFIGURATION
TestMe supports hierarchical configuration using nested \fBtestme.json5\fR files throughout your project structure.

.SS Configuration Discovery
TestMe discovers configuration files using the following priority order (highest to lowest):
.IP 1. 4
CLI arguments (highest priority)
.IP 2. 4
Test-specific \fBtestme.json5\fR (nearest to test file)
.IP 3. 4
Project \fBtestme.json5\fR (walking up directory tree)
.IP 4. 4
Built-in defaults (lowest priority)

.SS Nested Configuration Behavior
Each test file gets its own configuration resolution by walking up from the test file's directory to find the nearest \fBtestme.json5\fR file. This enables:
.IP \(bu 4
Project-wide defaults at the repository root
.IP \(bu 4
Module-specific overrides in subdirectories
.IP \(bu 4
Test-specific configuration closest to individual tests
.IP \(bu 4
Automatic merging with CLI arguments preserved

For example, a project structure like:
.nf
project/
├── testme.json5          # Project defaults
├── module-a/
│   ├── testme.json5      # Module-specific settings
│   └── test.tst.c
└── module-b/
    └── test.tst.c        # Uses project defaults
.fi

Configuration files support:

.SS Compiler Settings
Configure C compilation with custom compilers, flags, and libraries:
.nf
{
    compiler: {
        c: {
            compiler: "gcc",
            flags: ["-std=c99", "-Wall", "-Wextra"],
            libraries: ["m", "pthread", "mylib"]
        },
        es: {
            require: "testme"  // Modules to preload with --require
        }
    }
}
.fi

.SS Execution Settings
Control test execution behavior:
.nf
{
    execution: {
        timeout: 30,           // Timeout per test (seconds)
        parallel: true,        // Run tests in parallel
        workers: 4,            // Number of parallel workers
    }
}
.fi

.SS Output Settings
Control output formatting:
.nf
{
    output: {
        verbose: false,        // Show detailed output
        format: "simple",      // simple, detailed, json
        colors: true          // Enable colored output
    }
}
.fi

.SS Pattern Settings
Configure test discovery:
.nf
{
    patterns: {
        include: ["**/*.tst.c", "**/*.tst.sh"],
        exclude: ["**/node_modules/**", "**/.*/**"]
    }
}
.fi

.SS Test Control Settings
Configure whether tests are enabled, minimum depth requirements, and setup delays:
.nf
{
    enable: true,              // Enable, disable, or require explicit naming
    depth: 0,                  // Minimum depth required to run tests (default: 0)
}
.fi

The \fBenable\fR setting accepts three values:
.IP \(bu 4
\fBtrue\fR (default): Tests run normally when discovered by pattern matching
.IP \(bu 4
\fBfalse\fR: Tests are completely disabled and skipped
.IP \(bu 4
\fB'manual'\fR: Tests only run when explicitly named by full path or base name (excludes directory-level or wildcard patterns)

Set \fBenable: false\fR to disable all tests in a directory. Disabled directories are skipped during execution and excluded from \fB\-\-list\fR output. In verbose mode, disabled directories show a "🚫 Tests disabled" message.

Set \fBenable: 'manual'\fR to require explicit test naming. Manual tests are excluded when using directory-level patterns (e.g., running \fBtm\fR in a directory) or wildcard patterns (e.g., \fB*.tst.c\fR), but will run when named explicitly (e.g., \fBtm math\fR or \fBtm test/slow.tst.c\fR). This is useful for slow tests, destructive tests, or tests requiring special setup that should not run automatically.

Set \fBdepth: N\fR to require \fB\-\-depth N\fR or higher to run tests in this directory. This is useful for marking integration or resource-intensive tests that should only run when explicitly requested. Tests with higher depth requirements than the current \fB\-\-depth\fR value are skipped.

.SS Service Settings
Configure skip, environment, prep, setup and cleanup commands:
.nf
{
    services: {
        skip: "check-requirements",       // Check if tests should run (0=run, non-zero=skip)
        environment: "./detect-build.sh", // Emit environment variables (key=value lines)
        prep: "make build",
        setup: "docker-compose up -d",
        cleanup: "docker-compose down",
        skipTimeout: 30,                  // Timeout in seconds
        environmentTimeout: 30,           // Timeout in seconds
        prepTimeout: 30,                  // Timeout in seconds
        setupTimeout: 30,                 // Timeout in seconds
        cleanupTimeout: 10,               // Timeout in seconds
        delay: 3                          // Wait 3 seconds after setup before tests
    }
}
.fi

The skip command runs first to determine if tests should be executed. Exit code 0 enables tests, non-zero skips them. The skip script can output a message (stdout or stderr) explaining why tests are skipped, displayed in verbose mode.

The environment command runs after skip and emits environment variables as key=value lines on stdout. Each line should be in the format KEY=VALUE. These variables are merged with the environment configuration and made available to prep, setup, cleanup, and all tests. This is useful for dynamically detecting build artifacts, reading configuration from external sources, or computing values based on system state.

The prep command runs once before all tests begin and waits for completion. The setup command starts a background service that runs during test execution. The \fBdelay\fR field specifies seconds to wait after the setup service starts before beginning test execution, allowing time for service initialization. The cleanup command runs after all tests complete to clean up resources.

.SS Environment Variables
Configure environment variables available to all tests during execution. Supports platform-specific overrides via \fBwindows\fR, \fBmacosx\fR, and \fBlinux\fR keys:
.nf
{
    environment: {
        // Base environment variables (all platforms)
        TEST_MODE: "integration",
        BIN: "${../build/*/bin}",

        // Platform-specific variables (merged with base)
        windows: {
            PATH: "${../build/*/bin};%PATH%",
            LIB_EXT: ".dll"
        },
        linux: {
            LD_LIBRARY_PATH: "${../build/*/bin}:$LD_LIBRARY_PATH",
            LIB_EXT: ".so"
        },
        macosx: {
            DYLD_LIBRARY_PATH: "${../build/*/bin}:$DYLD_LIBRARY_PATH",
            LIB_EXT: ".dylib"
        }
    }
}
.fi

Environment variable values support \fB${...}\fR expansion using glob patterns. Paths are resolved relative to the configuration file's directory. Platform-specific variables are merged with base variables, with platform values overriding base values on matching platforms. This is useful for providing dynamic paths to build artifacts, libraries, and test data.

.SS Special Variables
TestMe provides special variables that can be used in compiler flags, library paths, and environment variables. These variables are automatically exported as environment variables (with TESTME_ prefix) to all tests and service scripts (skip, prep, setup, cleanup):

.TP
.B ${TESTDIR} or $TESTME_TESTDIR
Relative path from compiled executable to test file directory (e.g., "../..")
.TP
.B ${CONFIGDIR} or $TESTME_CONFIGDIR
Relative path from compiled executable to testme.json5 directory
.TP
.B ${OS} or $TESTME_OS
Operating system: "macosx", "linux", "windows"
.TP
.B ${ARCH} or $TESTME_ARCH
CPU architecture: "arm64", "x64", "x86"
.TP
.B ${PLATFORM} or $TESTME_PLATFORM
Combined OS-ARCH: "macosx-arm64", "linux-x64", "windows-x64"
.TP
.B ${CC} or $TESTME_CC
Compiler name: "gcc", "clang", "msvc"
.TP
.B ${PROFILE} or $TESTME_PROFILE
Build profile from \fB\-\-profile\fR option, config file, PROFILE environment variable, or default "dev"
.TP
.B $TESTME_VERBOSE
Set to "1" when \fB\-\-verbose\fR flag is used
.TP
.B $TESTME_DEPTH
Current depth value from \fB\-\-depth\fR flag
.TP
.B $TESTME_ITERATIONS
Iteration count from \fB\-\-iterations\fR flag (defaults to 1). TestMe does NOT automatically repeat test execution - this variable is provided for tests to implement their own iteration logic internally if needed.

These special variables are available in two ways:
.RS
.IP 1. 4
As \fB${...}\fR patterns for expansion in configuration values (compiler flags, library paths, environment values)
.IP 2. 4
As actual environment variables (with TESTME_ prefix) accessible in all test and service scripts via standard environment access methods (e.g., \fB$TESTME_PLATFORM\fR in shell scripts, \fBgetenv("TESTME_PLATFORM")\fR in C, \fBprocess.env.TESTME_PLATFORM\fR in JavaScript/TypeScript)
.RE

Example usage in compiler configuration:
.nf
{
    profile: "dev",  // Can be overridden by --profile or environment.PROFILE
    compiler: {
        c: {
            clang: {
                flags: [
                    "-I${CONFIGDIR}/../build/${PLATFORM}-${PROFILE}/inc",
                    "-L${CONFIGDIR}/../build/${PLATFORM}-${PROFILE}/bin",
                    "-Wl,-rpath,@executable_path/${CONFIGDIR}/../build/${PLATFORM}-${PROFILE}/bin"
                ]
            }
        }
    }
}
.fi

These variables ensure correct paths regardless of test nesting level and support platform-specific build configurations.

Tests can access these variables using standard environment variable mechanisms:
.IP \(bu 4
C tests: \fBgetenv("BIN")\fR
.IP \(bu 4
Shell tests: \fB$BIN\fR or \fB${BIN}\fR
.IP \(bu 4
JavaScript/TypeScript: \fBprocess.env.BIN\fR

Environment variables are automatically included in Xcode debugging projects when using \fB\-\-debug\fR mode.

.SH ARTIFACTS
C tests create build artifacts in \fB.testme\fR directories co-located with test files:

.TP
.B Compiled binaries
C source files are compiled to executables with names matching the test base name.
.TP
.B Compilation logs
\fBcompile.log\fR files contain compiler output for debugging compilation issues.
.TP
.B Debug symbols
Debug builds include .dSYM directories on macOS for debugging support.
.TP
.B Xcode projects
Debug mode creates Xcode project files for integrated debugging on macOS.

.SH PARALLEL EXECUTION
TestMe executes tests in parallel by default with configurable concurrency:

.TP
.B Batched processing
Tests are processed in batches to prevent system overload.
.TP
.B Fresh handler instances
Each test gets isolated handler instances to prevent race conditions.
.TP
.B Artifact isolation
Each test compiles in its own directory to avoid conflicts.
.TP
.B Configurable concurrency
Use \fBworkers\fR setting to tune based on system resources.

.SH OUTPUT MODES
TestMe provides three levels of output verbosity:

.TP
.B Default Mode
Shows test names as they execute with pass/fail status and execution time, followed by a summary.
.TP
.B Verbose Mode (\-\-verbose)
Includes all default output plus detailed error information, compilation commands, and sets TESTME_VERBOSE=1 for tests.
.TP
.B Quiet Mode (\-\-quiet)
Produces no output at all, only returns exit codes. Ideal for scripts and automated systems.

.SH ENVIRONMENT VARIABLES
TestMe sets and respects several environment variables:

.TP
.B TESTME_VERBOSE
Set to "1" when verbose mode is enabled. Tests can check this for detailed output.
.TP
.B TESTME_DEPTH
Set to the value provided by \fB\-\-depth\fR option. Used for nested test execution control.
.TP
.B PROFILE
Read as the default build profile if not specified in config or via \fB\-\-profile\fR. Used in ${PROFILE} variable expansion.
.TP
.B TMPDIR
Set to /tmp/claude/ for temporary file operations in sandboxed environments.

.SH EXIT STATUS
.TP
.B 0
All tests passed successfully.
.TP
.B 1
One or more tests failed, had errors, or compilation failed.
.TP
.B 2
Invalid command line arguments or configuration errors.

.SH EXAMPLES
.SS Getting Started
.TP
Create testme.json5 configuration file:
.B tm --init

.TP
Create a C test file from template:
.B tm --new math.c

.TP
Create a JavaScript test file:
.B tm --new api.js

.TP
Create a Shell test file:
.B tm --new test.sh

.SS Running Tests
.TP
Run all tests (shows test names as they execute):
.B tm

.TP
Run only C tests:
.B tm "*.tst.c"

.TP
Run specific test file:
.B tm "math.tst.c"

.TP
Run tests matching pattern:
.B tm "**/math*"

.TP
List all discoverable tests:
.B tm --list

.TP
Clean all test artifacts:
.B tm --clean

.TP
Run with verbose output:
.B tm -v "integration*"

.TP
Keep build artifacts for debugging:
.B tm --keep "*.tst.c"

.TP
Run tests one at a time with prompts:
.B tm --step

.TP
Set custom test depth:
.B tm --depth 5

.TP
Debug a specific C test:
.B tm --debug math.tst.c

.TP
Show compilation commands:
.B tm --show "*.tst.c"

.TP
Run silently with no output (for scripts):
.B tm --quiet

.TP
Use custom configuration:
.B tm -c /path/to/testme.json5

.TP
Change directory before running:
.B tm --chdir /path/to/tests

.TP
Run with specific build profile:
.B tm --profile release

.TP
Run with profile from environment:
.B PROFILE=prod tm

.SH FILES
.TP
.B testme.json5
Configuration file searched from current directory upward.
.TP
.B .testme/
Artifact directories created alongside test files for build outputs.
.TP
.B *.tst.sh, *.tst.c, *.tst.js, *.tst.ts, *.tst.es
Test files with recognized extensions.
.TP
.B testme.h
C testing utility header file with assertion and helper functions.
.TP
.B testme.js
JavaScript/TypeScript testing utility module with assertion and helper functions.

.SH DEBUGGING
For C tests, TestMe provides integrated debugging support:

.SS macOS (Xcode)
Use \fB\-\-debug\fR to create and open an Xcode project with proper build settings, include paths, and library linking. The project includes:
- All compiler flags from configuration
- Expanded library and include paths
- Direct dylib linking for runtime libraries
- Proper rpath configuration

.SS Linux (GDB)
Use \fB\-\-debug\fR to launch GDB with the compiled test binary. Provides command-line debugging with full symbol information.

.SH TROUBLESHOOTING
.TP
.B Compilation failures
Use \fB\-\-show\fR to see exact compiler commands and \fB\-\-keep\fR to examine compilation logs in .testme directories.
.TP
.B Library linking issues
Check library paths in configuration and ensure dylib files exist in specified locations.
.TP
.B Parallel execution issues
Reduce \fBworkers\fR setting if tests fail due to resource contention.
.TP
.B Permission errors
Ensure test files are readable and script files are executable.

.SH SEE ALSO
.BR gcc (1),
.BR clang (1),
.BR bun (1),
.BR gdb (1),
.BR xcodegen (1)

.SH AUTHOR
TestMe was written for embedded development environments requiring multi-language test execution with consistent tooling across C, shell scripts, JavaScript, and TypeScript.

.SH COPYRIGHT
This is free software; see the source for copying conditions.
